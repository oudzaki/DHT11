<!doctype html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DHT Dashboard</title>

  <!-- Chart.js (remplace Recharts) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --bg:#f7fafc;
      --card:#fff;
      --border:#e5e7eb;
      --muted:#64748b;
      --shadow: 0 6px 24px rgba(0,0,0,.06);
      --radius:16px;
    }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); }
    header{
      background:#fff; border-bottom:1px solid var(--border);
      padding:12px 20px; display:flex; justify-content:space-between; align-items:center;
      position: sticky; top: 0; z-index: 10;
    }
    main { max-width:1100px; margin:0 auto; padding:20px; }
    .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:16px; }
    @media (max-width: 900px){ .grid { grid-template-columns: 1fr; } }

    .card{
      border:1px solid var(--border); border-radius:var(--radius); padding:16px; background:var(--card);
      box-shadow: var(--shadow);
    }
    .metric-label{ opacity:.7; font-size:13px; }
    .metric-value{ font-size:24px; font-weight:700; }
    .metric-unit{ font-size:14px; margin-left:6px; opacity:.8; }
    .metric-sub{ font-size:14px; opacity:.7; margin-top:4px; }

    h3{ margin: 0 0 10px; }

    .table-wrap{
      overflow-y:auto; max-height:380px;
      border-radius:12px; border:1px solid #f1f5f9;
    }
    table{ width:100%; border-collapse:collapse; background:#fff; }
    th{
      position:sticky; top:0; z-index:1;
      background:#fff; text-align:left; padding:8px; border-bottom:1px solid var(--border);
      font-weight: 600; font-size: 14px;
    }
    td{ padding:8px; border-bottom:1px solid #f1f5f9; font-size:14px; }

    .muted{ color: var(--muted); }
    .row{ display:flex; gap:12px; align-items:center; }
    .right{ text-align:right; }
    .hidden{ display:none !important; }

    .login-box{ display:grid; gap:10px; max-width:360px; }
    input, button{
      padding:10px 12px; border:1px solid var(--border); border-radius:12px;
      font-size:14px;
    }
    button{ cursor:pointer; font-weight:600; }
    .danger{ color:#b91c1c; }
  </style>
</head>

<body>
  <header>
    <div style="font-weight:700">DHT Dashboard</div>
    <div class="muted" style="font-size:13px">Capteur: <span id="sensorLabel"></span></div>
  </header>

  <main>
    <!-- Login (si tokens manquants) -->
    <section id="loginSection" class="card hidden">
      <h3>Connexion</h3>
      <div class="login-box">
        <input id="username" placeholder="username" autocomplete="username">
        <input id="password" placeholder="password" type="password" autocomplete="current-password">
        <button id="loginBtn">Se connecter</button>
        <div id="loginError" class="danger"></div>
        <div class="muted" style="font-size:13px">
          Si ton endpoint readings est public, tu peux supprimer cette section.
        </div>
      </div>
    </section>

    <!-- Dashboard -->
    <section id="dashboardSection" class="hidden">
      <div class="grid">
        <div class="card">
          <div class="metric-label">Température</div>
          <div class="metric-value"><span id="tempValue">—</span> <span class="metric-unit">°C</span></div>
        </div>
        <div class="card">
          <div class="metric-label">Humidité</div>
          <div class="metric-value"><span id="humValue">—</span> <span class="metric-unit">%</span></div>
        </div>
        <div class="card">
          <div class="metric-label">Dernière mesure</div>
          <div class="metric-value" id="lastDate">—</div>
          <div class="metric-sub" id="lastFromNow"></div>
        </div>
      </div>

      <div class="card" style="margin-top:20px">
        <h3>Historique (les 200 dernières mesures)</h3>
        <div style="height:320px">
          <canvas id="chart"></canvas>
        </div>
      </div>

      <div class="card" style="margin-top:20px">
        <h3>Table des mesures</h3>
        <div id="loadingText">Chargement...</div>
        <div id="tableWrap" class="table-wrap hidden">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Température (°C)</th>
                <th>Humidité (%)</th>
                <th>Capteur</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===============================
    // 1) CONFIG (équivalent .env)
    // ===============================
    const API_BASE = "http://192.168.1.7:8000";
    const SENSOR = "esp8266-1";
    document.getElementById("sensorLabel").textContent = SENSOR;

    // ===============================
    // 2) TOKENS (localStorage)
    // ===============================
    function getTokens() {
      const access = localStorage.getItem("access_token");
      const refresh = localStorage.getItem("refresh_token");
      if (access && refresh) return { access, refresh };
      return null;
    }
    function setTokens(tokens) {
      if (!tokens) {
        localStorage.removeItem("access_token");
        localStorage.removeItem("refresh_token");
      } else {
        localStorage.setItem("access_token", tokens.access);
        localStorage.setItem("refresh_token", tokens.refresh);
      }
    }

    // ===============================
    // 3) FETCH helper (auth ou public)
    // ===============================
    async function apiFetch(path, { method="GET", body=null, auth=false } = {}) {
      const headers = { "Content-Type": "application/json" };
      if (auth) {
        const tk = getTokens();
        if (tk?.access) headers.Authorization = `Bearer ${tk.access}`;
      }

      const res = await fetch(API_BASE + path, {
        method,
        headers,
        body: body ? JSON.stringify(body) : null,
      });

      if (!res.ok) {
        const text = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${res.statusText} - ${text}`);
      }
      // peut être vide
      const contentType = res.headers.get("content-type") || "";
      if (contentType.includes("application/json")) return res.json();
      return null;
    }

    // ===============================
    // 4) API calls (readings)
    // ===============================
    async function getLatest(sensorName) {
      return apiFetch(`/api/readings/latest/${encodeURIComponent(sensorName)}/`, { auth:false });
    }
    async function getAllReadings() {
      return apiFetch(`/api/readings/`, { auth:false });
    }

    // OPTIONAL: login si tu as un endpoint JWT (à adapter à ton backend)
    async function login(username, password) {
      // ⚠️ adapte selon ton backend (ex: /api/token/ ou /api/auth/jwt/create/)
      // Exemple commun Django SimpleJWT: POST /api/token/
      const data = await apiFetch(`/api/token/`, {
        method: "POST",
        body: { username, password },
        auth: false,
      });
      // attendre { access, refresh }
      return data;
    }

    // ===============================
    // 5) DATE helpers
    // ===============================
    function pad2(n){ return String(n).padStart(2, "0"); }
    function formatDateTime(iso) {
      const d = new Date(iso);
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      const day = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mm = pad2(d.getMinutes());
      const ss = pad2(d.getSeconds());
      return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
    }
    function fromNowFr(iso) {
      const diffMs = Date.now() - new Date(iso).getTime();
      const s = Math.floor(diffMs / 1000);
      if (s < 10) return "à l’instant";
      if (s < 60) return `il y a ${s} secondes`;
      const m = Math.floor(s / 60);
      if (m < 60) return `il y a ${m} minute${m>1?"s":""}`;
      const h = Math.floor(m / 60);
      if (h < 24) return `il y a ${h} heure${h>1?"s":""}`;
      const d = Math.floor(h / 24);
      return `il y a ${d} jour${d>1?"s":""}`;
    }

    // ===============================
    // 6) Chart.js setup
    // ===============================
    let chart;
    function niceDomain(values, hardPad=0, percentPad=0.1) {
      if (!values.length) return [0, 1];
      let min = Math.min(...values);
      let max = Math.max(...values);
      if (min === max) {
        min -= Math.max(hardPad, 1);
        max += Math.max(hardPad, 1);
      } else {
        const pad = (max - min) * percentPad + hardPad;
        min -= pad;
        max += pad;
      }
      return [Math.floor(min), Math.ceil(max)];
    }

    function renderChart(readings) {
      const ordered = [...readings].reverse(); // comme ton chartData (reverse)
      const labels = ordered.map(r => {
        const d = new Date(r.created_at);
        return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      });
      const temps = ordered.map(r => r.temperature);
      const hums  = ordered.map(r => r.humidity);

      const [tMin, tMax] = niceDomain(temps, 1);
      const [hMin, hMax] = niceDomain(hums, 2);

      const ctx = document.getElementById("chart");
      if (chart) chart.destroy();

      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "température",
              data: temps,
              borderColor: "#ef4444",
              tension: 0.35,
              pointRadius: 0,
              yAxisID: "yTemp",
            },
            {
              label: "humidité",
              data: hums,
              borderColor: "#3b82f6",
              tension: 0.35,
              pointRadius: 0,
              yAxisID: "yHum",
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          scales: {
            yTemp: {
              type: "linear",
              position: "left",
              min: tMin,
              max: tMax,
              ticks: { callback: (v) => `${v}°C` }
            },
            yHum: {
              type: "linear",
              position: "right",
              min: hMin,
              max: hMax,
              grid: { drawOnChartArea: false },
              ticks: { callback: (v) => `${v}%` }
            },
            x: { ticks: { maxRotation: 0, autoSkip: true } }
          }
        }
      });
    }

    // ===============================
    // 7) Render UI
    // ===============================
    function setMetric(latest) {
      document.getElementById("tempValue").textContent =
        latest ? Number(latest.temperature).toFixed(1) : "—";
      document.getElementById("humValue").textContent =
        latest ? Number(latest.humidity).toFixed(1) : "—";

      document.getElementById("lastDate").textContent =
        latest ? formatDateTime(latest.created_at) : "—";

      document.getElementById("lastFromNow").textContent =
        latest ? `(${fromNowFr(latest.created_at)})` : "";
    }

    function renderTable(readings) {
      const tbody = document.getElementById("tbody");
      tbody.innerHTML = "";
      for (const r of readings) {
        const tr = document.createElement("tr");

        const tdDate = document.createElement("td");
        tdDate.textContent = formatDateTime(r.created_at);

        const tdT = document.createElement("td");
        tdT.textContent = Number(r.temperature).toFixed(1);

        const tdH = document.createElement("td");
        tdH.textContent = Number(r.humidity).toFixed(1);

        const tdS = document.createElement("td");
        tdS.textContent = r.sensor;

        tr.append(tdDate, tdT, tdH, tdS);
        tbody.appendChild(tr);
      }
    }

    // ===============================
    // 8) Boot logic (guard)
    // ===============================
    async function loadDashboard() {
      document.getElementById("dashboardSection").classList.remove("hidden");
      document.getElementById("loginSection").classList.add("hidden");

      try {
        const [lt, all] = await Promise.all([getLatest(SENSOR), getAllReadings()]);
        const list = (all || []).slice(0, 200);

        setMetric(lt);
        renderChart(list);
        renderTable(list);

      } finally {
        document.getElementById("loadingText").classList.add("hidden");
        document.getElementById("tableWrap").classList.remove("hidden");
      }
    }

    function showLogin() {
      document.getElementById("loginSection").classList.remove("hidden");
      document.getElementById("dashboardSection").classList.add("hidden");
    }

    // Si tu veux forcer la protection comme ProtectedRoute:
    const REQUIRE_AUTH = false; // mets true si readings doivent être protégés

    window.addEventListener("DOMContentLoaded", async () => {
      try {
        if (REQUIRE_AUTH && !getTokens()?.access) {
          showLogin();
        } else {
          await loadDashboard();
        }
      } catch (e) {
        console.error(e);
        // si erreur et auth activé, propose login
        if (REQUIRE_AUTH) showLogin();
        else alert("Erreur API: " + e.message);
      }
    });

    // Login button
    document.getElementById("loginBtn").addEventListener("click", async () => {
      const u = document.getElementById("username").value.trim();
      const p = document.getElementById("password").value.trim();
      const err = document.getElementById("loginError");
      err.textContent = "";
      try {
        const tokens = await login(u, p);
        setTokens(tokens);
        await loadDashboard();
      } catch (e) {
        err.textContent = "Échec login: " + e.message;
      }
    });
  </script>
</body>
</html>
